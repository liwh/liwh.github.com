<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Code for fun]]></title>
  <link href="http://liwh.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://liwh.github.com/"/>
  <updated>2012-01-03T16:42:54+08:00</updated>
  <id>http://liwh.github.com/</id>
  <author>
    <name><![CDATA[liwh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GCD介绍]]></title>
    <link href="http://liwh.github.com/blog/2012/01/03/ios-gcd/"/>
    <updated>2012-01-03T16:21:00+08:00</updated>
    <id>http://liwh.github.com/blog/2012/01/03/ios-gcd</id>
    <content type="html"><![CDATA[<p>GCD是ios 4.0引入用于在应用程序中管理多个任务执行的技术。是C API的一部分。一般我们将其替代作为应用程序的多线程处理。
GCD的函数一般以"dispatch_"开头，我们可以使用这个执行某些后台任务，然后返回处理主线程的代码。</p>

<h4>例子</h4>

<p>下面介绍一个例子，创建gcd队列下载图片:</p>

<p>主要代码：</p>

<p>```obj-c
- (void)viewWillAppear:(BOOL)animated
{
  tch_queue_t downloadQueue = dispatch_queue_create(“image downloader”, NULL);
  dispatch_async(downloadQueue, ^{</p>

<pre><code>  NSData *imageData = [NSData dataWithContentsOfURL:networkURL];
  //UIKit使用只能在main thread中
  dispatch_async(dispatch_get_main_queue(), ^{
    UIImage *image = [UIImage imageWithData:imageData];
    self.imageView.image = image;
    self.imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);
    self.scrollView.contentSize = image.size;
    });
  });
</code></pre>

<p>  dispatch_release(downloadQueue);
}
```</p>

<h4>参考资料</h4>

<p><a href="http://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/rexerence.html">GCD</a></p>
]]></content>
  </entry>
  
</feed>
