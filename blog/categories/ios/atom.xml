<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Code for fun]]></title>
  <link href="http://liwh.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://liwh.github.com/"/>
  <updated>2012-01-06T13:54:22+08:00</updated>
  <id>http://liwh.github.com/</id>
  <author>
    <name><![CDATA[liwh]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[how-to-draw-circle]]></title>
    <link href="http://liwh.github.com/blog/2012/01/06/how-to-draw-circle/"/>
    <updated>2012-01-06T00:07:00+08:00</updated>
    <id>http://liwh.github.com/blog/2012/01/06/how-to-draw-circle</id>
    <content type="html"><![CDATA[<p>这里介绍，如何实现在UIView中画圆，下面是主要代码：</p>

<p>```obj-c
-(void)drawCircleAtPoint:(CGPoint)p withRadius:(CGFloat)radius inContext:(CGContextRef)context
{</p>

<pre><code>UIGraphicsPushContext(context);
CGContextBeginPath(context);
CGContextAddArc(context, p.x, p.y, radius, 0, 2*M_PI, YES);
CGContextStrokePath(context);
UIGraphicsPopContext();
</code></pre>

<p>}</p>

<ul>
<li><p>(void)drawRect:(CGRect)rect
{
  // Drawing code
  CGContextRef context = UIGraphicsGetCurrentContext();
  CGPoint midPoint;
  midPoint.x = self.bounds.origin.x + self.bounds.size.width / 2 ;
  midPoint.y = self.bounds.origin.y + self.bounds.size.height / 2 ;
  CGFloat size = self.bounds.size.width / 2;
  if (self.bounds.size.height &lt; self.bounds.size.width) size = self.bounds.size.height / 2 ;</p>

<p>  CGContextSetLineWidth(context, 5.0);
  [[UIColor redColor] setStroke];
  [self drawCircleAtPoint:midPoint withRadius:size inContext:context];
｝
```</p></li>
</ul>


<p>显示如下：</p>

<p><img src="http://ww4.sinaimg.cn/mw600/6757a08cjw1dosny8myysj.jpg" alt="image" /></p>

<p><code>obj-c
//Begin the path￼￼CGContextBeginPath(context);
//Move around, add lines or arcs to the pathCGContextMoveToPoint(context, 75, 10);CGContextAddLineToPoint(context, 160, 150);CGContextAddLineToPoint(context, 10, 150);//Close the path (connects the last point back to the first) CGContextClosePath(context); // not strictly required
//Actually the above draws nothing (yet)!//You have to set the graphics state and then fill/stroke the above path to see anything. [[UIColor greenColor] setFill]; // object-oriented convenience method (more in a moment) [[UIColor redColor] setStroke];￼￼￼CGContextDrawPath(context,kCGPathFillStroke); //kCGPathFillStrokeisaconstant
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD介绍]]></title>
    <link href="http://liwh.github.com/blog/2012/01/03/ios-gcd/"/>
    <updated>2012-01-03T16:21:00+08:00</updated>
    <id>http://liwh.github.com/blog/2012/01/03/ios-gcd</id>
    <content type="html"><![CDATA[<p>GCD是ios 4.0引入用于在应用程序中管理多个任务执行的技术。是C API的一部分。一般我们将其替代作为应用程序的多线程处理。
GCD的函数一般以"dispatch_"开头，我们可以使用这个执行某些后台任务，然后返回处理主线程的代码。</p>

<h4>例子</h4>

<p>下面介绍一个例子，创建gcd队列下载图片:</p>

<p>主要代码：</p>

<p>```obj-c
- (void)viewWillAppear:(BOOL)animated
{
  tch_queue_t downloadQueue = dispatch_queue_create(“image downloader”, NULL);
  dispatch_async(downloadQueue, ^{</p>

<pre><code>  NSData *imageData = [NSData dataWithContentsOfURL:networkURL];
  //UIKit使用只能在main thread中
  dispatch_async(dispatch_get_main_queue(), ^{
    UIImage *image = [UIImage imageWithData:imageData];
    self.imageView.image = image;
    self.imageView.frame = CGRectMake(0, 0, image.size.width, image.size.height);
    self.scrollView.contentSize = image.size;
    });
  });
</code></pre>

<p>  dispatch_release(downloadQueue);
}
```</p>

<h4>参考资料</h4>

<p><a href="http://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/rexerence.html">GCD</a></p>
]]></content>
  </entry>
  
</feed>
